package quilt.internal;

import net.fabricmc.mappingio.tree.MappingTree;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.io.CleanupMode;
import org.junit.jupiter.api.io.TempDir;
import quilt.internal.tasks.build.AddProposedMappingsTask;
import quilt.internal.tasks.build.BuildMappingsTinyTask;
import quilt.internal.tasks.build.InvertPerVersionMappingsTask;
import quilt.internal.tasks.build.MergeIntermediaryTask;
import quilt.internal.tasks.build.MergeTinyTask;
import quilt.internal.tasks.build.MergeTinyV2Task;
import quilt.internal.tasks.build.RemoveIntermediaryTask;
import quilt.internal.tasks.unpick.CombineUnpickDefinitionsTask;
import quilt.internal.tasks.unpick.RemapUnpickDefinitionsTask;
import quilt.internal.util.JarRemapper;
import quilt.internal.util.UnpickFile;

import java.io.File;
import java.io.IOException;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Collection;
import java.util.List;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.*;

@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class TasksTest {
    private static final String PER_VERSION_NAMESPACE = Constants.PER_VERSION_MAPPINGS_NAME;
    private static final Path OBF_JAR = Path.of("build/libs/test-input-obf.jar").toAbsolutePath();

    @TempDir(
        // DEBUG
        // cleanup = CleanupMode.NEVER
        cleanup = CleanupMode.ON_SUCCESS
    )
    private static Path testProjectDir;
    private static Path mappingsDir;
    private static Path profilePath;
    private static Path unpickDefinitions;

    private static Path perVersionMappingsJar;
    private static Path outputsDir;
    private static Path perVersionMappings;
    private static Path buildMappingsTinyOutput;
    private static Path invertedPerVersionMappings;
    private static Path insertAutoGeneratedMappingsOutput;
    private static Path mergeTinyV2Output;
    private static Path namedJar;
    private static Path combineUnpickDefinitionsOutput;
    private static Path intermediaryMappings;
    private static Path mergeIntermediaryOutput;

    private static Path getResource(String name) throws URISyntaxException {
        return Path.of(TasksTest.class.getResource(name).toURI());
    }

    @BeforeAll
    public static void setup() throws Exception {
        // DEBUG
        // System.out.println("Setting up test project at " + testProjectDir.toAbsolutePath());
        Path source = getResource("/testProject");

        try (Stream<Path> files = Files.walk(source)) {
            files.forEach(p -> {
                Path relative = source.relativize(p);
                try {
                    if (!Files.isDirectory(relative)) {
                        Files.copy(p, testProjectDir.resolve(relative));
                    }
                } catch (IOException e) {
                    throw new RuntimeException("Failed to copy " + relative, e);
                }
            });
        }

        mappingsDir = testProjectDir.resolve("mappings/");
        profilePath = testProjectDir.resolve("enigma_profile.json");
        unpickDefinitions = testProjectDir.resolve("unpick-definitions/");

        perVersionMappings = getResource("/test-intermediate.tiny");
        perVersionMappingsJar = testProjectDir.resolve("test-hashed.jar");
        outputsDir = testProjectDir.resolve("outputs/");
        Files.createDirectories(outputsDir);

        // Map the test input jar
        JarRemapper.mapJar(perVersionMappingsJar, OBF_JAR, perVersionMappings, new Path[0], "official", PER_VERSION_NAMESPACE, null);

        intermediaryMappings = getResource("/test-intermediate-alt.tiny");
    }

    @Test
    @Order(1)
    public void testBuildMappingsTiny() throws Exception {
        Path output = outputsDir.resolve("built-mappings.tiny");
        buildMappingsTinyOutput = output;
        BuildMappingsTinyTask.buildMappingsTiny(
            perVersionMappingsJar,
            mappingsDir,
            output
        );

        MappingTree tree = TestUtil.readTinyV2(output);
        assertEquals(PER_VERSION_NAMESPACE, tree.getSrcNamespace());
        assertEquals("named", tree.getDstNamespaces().get(0));
        assertNotNull(tree.getClass("com/example/u/C_001"));
        assertEquals("com/example/AClass", tree.getClass("com/example/u/C_001").getName("named"));
    }

    @Test
    @Order(2)
    public void testInvertPerVersionMappings() throws Exception {
        Path output = outputsDir.resolve("test-intermediate-inverted.tiny");
        invertedPerVersionMappings = output;
        InvertPerVersionMappingsTask.invertMappings(perVersionMappings.toFile(), output.toFile());

        MappingTree inputTree = TestUtil.readTinyV2(perVersionMappings);
        MappingTree outputTree = TestUtil.readTinyV2(output);
        assertEquals(inputTree.getSrcNamespace(), outputTree.getDstNamespaces().get(0));
        assertEquals(inputTree.getDstNamespaces().get(0), outputTree.getSrcNamespace());
        assertEquals(inputTree.getClass("com/example/u/C_001", 0).getName(-1), outputTree.getClass("com/example/u/C_001").getName(0));
    }

    private void testMergedTree(MappingTree tree, String intermediateNamespace) {
        assertEquals("official", tree.getSrcNamespace());
        assertIterableEquals(List.of(intermediateNamespace, "named"), tree.getDstNamespaces());
        assertNotNull(tree.getClass("com/example/AClass", 1));
        assertFalse(tree.getClass("b").getName("named").isEmpty());
        assertNotNull(tree.getClass("c"));
        assertFalse(tree.getClass("c").getName(0).isEmpty()); // Should always have a per-version name
        assertNotNull(tree.getClass("c$a"));
        assertFalse(tree.getClass("c$a").getName(0).isEmpty());
        // Unmapped methods should not have a `named` name
        assertNull(tree.getMethod("c$a", "a", "()[Lc$a;").getName("named"));

        assertNotNull(tree.getClass("h"));
        // Unobfuscated methods should either not have a mapping, or be remapped to the original name in the named namespace
        MappingTree.MethodMapping unobfMethod = tree.getMethod("h", "get", "(I)I");
        assertTrue(unobfMethod == null || unobfMethod.getName("named").equals("get"));
    }

    @Test
    @Order(3)
    public void testMergeTiny() throws Exception {
        Path output = outputsDir.resolve("merged.tiny");
        MergeTinyTask.mergeMappings(buildMappingsTinyOutput, invertedPerVersionMappings, output);

        MappingTree tree = TestUtil.readTinyV2(output);
        testMergedTree(tree, PER_VERSION_NAMESPACE);
    }

    @Test
    @Order(4)
    public void testInsertAutoGeneratedMappings() throws Exception {
        Path output = outputsDir.resolve("insertAutoGeneratedMappings.tiny");
        insertAutoGeneratedMappingsOutput = output;
        AddProposedMappingsTask.addProposedMappings(buildMappingsTinyOutput, output, perVersionMappingsJar, profilePath);

        MappingTree tree = TestUtil.readTinyV2(output);
        MappingTree inputTree = TestUtil.readTinyV2(buildMappingsTinyOutput);
        assertEquals(inputTree.getSrcNamespace(), tree.getSrcNamespace());
        assertEquals(inputTree.getDstNamespaces(), tree.getDstNamespaces());

        assertEquals("com/example/AClass", tree.getClass("com/example/u/C_001").getName("named"));
        assertEquals("com/example/BEnum", tree.getClass("com/example/u/C_002").getName("named"));

        // f_004 FIRST
        MappingTree.FieldMapping insertedField = tree.getField("com/example/u/C_002", "f_004", "Lcom/example/u/C_002;");
        assertNotNull(insertedField);
        assertEquals("FIRST", insertedField.getName("named"));
        MappingTree.FieldMapping prevMapping = inputTree.getField("com/example/u/C_002", "f_004", "Lcom/example/u/C_002;");
        assertNull(prevMapping);

        // f_011 NORMAL
        MappingTree.FieldMapping insertedField2 = tree.getField("com/example/u/C_003$C_004", "f_011", "Lcom/example/u/C_003$C_004;");
        assertNotNull(insertedField2);
        assertEquals("NORMAL", insertedField2.getName("named"));

        // f_015 left
        MappingTree.FieldMapping insertedField3 = tree.getField("com/example/u/C_005", "f_015", "Ljava/lang/Object;");
        assertNotNull(insertedField3);
        assertEquals("left", insertedField3.getName("named"));
        // m_013 right
        MappingTree.MethodMapping insertedMethod = tree.getMethod("com/example/u/C_005", "m_013", "()Ljava/lang/Object;");
        assertNotNull(insertedMethod);
        assertEquals("right", insertedMethod.getName("named"));

        MappingTree.MethodMapping insertedMethod2 = tree.getMethod("com/example/u/C_005", "equals", "(Ljava/lang/Object;)Z");
        assertNotNull(insertedMethod2);
        assertEquals("o", insertedMethod2.getArg(-1, 1, null).getName("named"));

        MappingTree.MethodMapping insertedMethod3 = tree.getMethod("com/example/u/C_005", "<init>", "(Ljava/lang/Object;Ljava/lang/Object;)V");
        assertNotNull(insertedMethod3);
        assertEquals("left", insertedMethod3.getArg(-1, 1, null).getName("named"));
        assertEquals("right", insertedMethod3.getArg(-1, 2, null).getName("named"));
    }

    @Test
    @Order(5)
    public void testMergeTinyV2() throws Exception {
        Path output = outputsDir.resolve("merged-v2.tiny");
        mergeTinyV2Output = output;
        MergeTinyV2Task.mergeMappings(insertAutoGeneratedMappingsOutput, invertedPerVersionMappings, output);

        MappingTree tree = TestUtil.readTinyV2(output);
        testMergedTree(tree, PER_VERSION_NAMESPACE);
        // com/example/u/C_002 f_004 FIRST
        assertEquals("FIRST", tree.getField("b", "a", "Lb;").getName("named"));
        // com/example/u/C_003$C_004 f_011 NORMAL
        assertEquals("NORMAL", tree.getField("c$a", "a", "Lc$a;").getName("named"));
    }

    private void mapNamedJar() {
        if (namedJar != null) return;
        namedJar = testProjectDir.resolve("test-named.jar");
        JarRemapper.mapJar(namedJar, perVersionMappingsJar, mergeTinyV2Output, new Path[0], PER_VERSION_NAMESPACE, "named", null);
    }

    @Test
    @Order(6)
    public void testCombineUnpickDefinitions() throws Exception {
        Path output = outputsDir.resolve("combined-definitions.unpick");
        combineUnpickDefinitionsOutput = output;
        Collection<File> input = List.of(unpickDefinitions.toFile().listFiles());
        CombineUnpickDefinitionsTask.combineUnpickDefinitions(input, output);

        mapNamedJar();
        UnpickFile file = TestUtil.readUnpickFile(output, namedJar);
        assertTrue(file.containsGroup("e_flags"));
        assertTrue(file.isFlagGroup("e_flags"));
        assertEquals("e_flags", file.getParameterConstantGroup("com/example/EClass", "m1", "(I)V", 0));

        assertTrue(file.containsGroup("f_flags"));
        assertFalse(file.isSimpleConstantGroup("f_flags"));
        assertEquals("f_flags", file.getParameterConstantGroup("com/example/FEnum", "<init>", "(Ljava/lang/String;II)V", 0));

        assertTrue(file.containsGroup("g_type"));
        assertTrue(file.isSimpleConstantGroup("g_type"));
        assertEquals("g_type", file.getParameterConstantGroup("com/example/GClass", "fromType", "(I)Ljava/lang/String;", 0));
        assertEquals("g_type", file.getReturnConstantGroup("com/example/GClass", "toType", "(Ljava/lang/String;)I"));
    }

    @Test
    @Order(7)
    public void testRemapUnpickDefinitions() throws Exception {
        Path output = outputsDir.resolve("remapped-definitions.unpick");
        RemapUnpickDefinitionsTask.remapUnpickDefinitions(combineUnpickDefinitionsOutput, mergeTinyV2Output, output);

        UnpickFile file = TestUtil.readUnpickFile(output, perVersionMappingsJar);
        assertTrue(file.containsGroup("e_flags"));
        assertTrue(file.isFlagGroup("e_flags"));
        assertEquals("e_flags", file.getParameterConstantGroup("com/example/u/C_006", "m_014", "(I)V", 0));

        assertTrue(file.containsGroup("f_flags"));
        assertFalse(file.isSimpleConstantGroup("f_flags"));
        assertEquals("f_flags", file.getParameterConstantGroup("com/example/u/C_007", "<init>", "(Ljava/lang/String;II)V", 0));

        assertTrue(file.containsGroup("g_type"));
        assertTrue(file.isSimpleConstantGroup("g_type"));
        assertEquals("g_type", file.getParameterConstantGroup("com/example/u/C_008", "m_023", "(I)Ljava/lang/String;", 0));
        assertEquals("g_type", file.getReturnConstantGroup("com/example/u/C_008", "m_024", "(Ljava/lang/String;)I"));
    }

    @Test
    @Order(8)
    public void testMergeIntermediary() throws Exception {
        Path output = outputsDir.resolve("merged-intermediary.tiny");
        mergeIntermediaryOutput = output;
        MergeIntermediaryTask.mergeMappings(intermediaryMappings, mergeTinyV2Output, output);

        MappingTree tree = TestUtil.readTinyV2(output);
        assertEquals("official", tree.getSrcNamespace());
        assertEquals("intermediary", tree.getDstNamespaces().get(0));
        assertEquals("named", tree.getDstNamespaces().get(1));
        testMergedTree(tree, "intermediary");

        MappingTree.ClassMapping keep = tree.getClass("quilt/internal/input/Keep");
        assertEquals(keep.getName("official"), keep.getName("intermediary"));
        assertNull(keep.getName("named"));
        MappingTree.ClassMapping keep1 = tree.getClass("quilt/internal/input/Keep$1");
        assertEquals(keep1.getName("official"), keep1.getName("intermediary"));
        assertNull(keep1.getName("named"));
        MappingTree.ClassMapping keep2 = tree.getClass("quilt/internal/input/Keep$2");
        assertNull(keep2.getName("intermediary"));
        assertEquals(keep2.getName("official"), keep2.getName("named"));

        // TODO: Is mapping specialized methods really necessary?
        // MappingTree.ClassMapping jClass = tree.getClass("j");
        // assertEquals("com/example/class_011", jClass.getName("intermediary"));
        // assertNull(jClass.getName("named"));
        // assertNull(jClass.getMethod("a", "(Ljava/util/Collection;)V").getName("named"));
        // assertNull(jClass.getMethod("b", "()Ljava/util/Collection;").getName("named"));

        MappingTree.ClassMapping kClass = tree.getClass("k");
        assertEquals("com/example/class_012", kClass.getName("intermediary"));
        // There's no way to fix this as far as I can tell, since inner classes need their parents to have matching in the same namespaces
        assertEquals("com/example/u/C_012", kClass.getName("named"));
        MappingTree.ClassMapping kInnerClass = tree.getClass("k$a");
        assertEquals("com/example/class_012$class_013", kInnerClass.getName("intermediary"));
        assertEquals("com/example/u/C_012$AInner", kInnerClass.getName("named"));
        MappingTree.ClassMapping kInnerInnerClass = tree.getClass("k$a$a");
        assertEquals("com/example/class_012$class_013$class_014", kInnerInnerClass.getName("intermediary"));
        // assertNull(kInnerInnerClass.getName("named"));

        MappingTree.FieldMapping f032 = tree.getField("k", "a", "Ljava/lang/String;");
        assertEquals("f1", f032.getComment());
        // assertNull(f032.getName("named"));
        MappingTree.MethodMapping m029 = tree.getMethod("k", "a", "(Ljava/lang/String;)V");
        assertEquals("s", m029.getArg(-1, 1, null).getName("named"));
        // assertNull(m029.getName("named"));
        MappingTree.MethodMapping m030 = tree.getMethod("k", "a", "()I");
        assertEquals("m2", m030.getComment());
        // assertNull(m030.getName("named"));
        MappingTree.MethodMapping m031 = tree.getMethod("k$a", "a", "(Ljava/lang/String;)I");
        assertEquals("m3", m031.getComment());
        // assertNull(m031.getName("named"));
        assertEquals("s", m031.getArg(-1, 1, null).getName("named"));
    }

    @Test
    @Order(9)
    public void testRemoveIntermediary() throws Exception {
        Path output = outputsDir.resolve("mappings-intermediary.tiny");
        RemoveIntermediaryTask.removeIntermediary(mergeIntermediaryOutput, output);

        MappingTree tree = TestUtil.readTinyV2(output);
        assertEquals("intermediary", tree.getSrcNamespace());
        assertEquals("named", tree.getDstNamespaces().get(0));
        // com/example/class_002 field_004 FIRST
        assertEquals("FIRST", tree.getField("com/example/class_002", "field_004", "Lcom/example/class_002;").getName("named"));
        // com/example/class_003$class_004 field_011 NORMAL
        assertEquals("NORMAL", tree.getField("com/example/class_003$class_004", "field_011", "Lcom/example/class_003$class_004;").getName("named"));

        MappingTree.ClassMapping keep2 = tree.getClass("quilt/internal/input/Keep$2");
        assertEquals("quilt/internal/input/Keep$2", keep2.getName("named"));
    }
}
