package quilt.internal;

import net.fabricmc.mappingio.tree.MappingTree;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.io.CleanupMode;
import org.junit.jupiter.api.io.TempDir;
import quilt.internal.tasks.build.AddProposedMappingsTask;
import quilt.internal.tasks.build.BuildMappingsTinyTask;
import quilt.internal.tasks.build.InvertPerVersionMappingsTask;
import quilt.internal.tasks.build.MergeTinyTask;
import quilt.internal.tasks.build.MergeTinyV2Task;
import quilt.internal.util.JarRemapper;

import java.io.IOException;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.*;

@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class TasksTest {
    private static final String PER_VERSION_NAMESPACE = Constants.PER_VERSION_MAPPINGS_NAME;
    private static final Path OBF_JAR = Path.of("build/libs/test-input-obf.jar");

    @TempDir(
        // DEBUG
        cleanup = CleanupMode.NEVER
    )
    private static Path testProjectDir;
    private static Path mappingsDir;
    private static Path perVersionMappingsJar;
    private static Path outputsDir;
    private static Path perVersionMappings;
    private static Path buildMappingsTinyOutput;
    private static Path invertedPerVersionMappings;
    private static Path mergeTinyOutput;
    private static Path insertAutoGeneratedMappingsOutput;

    private static Path getResource(String name) throws URISyntaxException {
        return Path.of(TasksTest.class.getResource(name).toURI());
    }

    @BeforeAll
    public static void setup() throws Exception {
        // DEBUG
        System.out.println("Setting up test project at " + testProjectDir.toAbsolutePath());
        Path source = getResource("/testProject");

        try (Stream<Path> files = Files.walk(source)) {
            files.forEach(p -> {
                Path relative = source.relativize(p);
                try {
                    if (!Files.isDirectory(relative)) {
                        Files.copy(p, testProjectDir.resolve(relative));
                    }
                } catch (IOException e) {
                    throw new RuntimeException("Failed to copy " + relative, e);
                }
            });
        }

        mappingsDir = testProjectDir.resolve("mappings/");
        perVersionMappings = getResource("/test-intermediate.tiny");
        perVersionMappingsJar = testProjectDir.resolve("test-hashed.jar");
        outputsDir = testProjectDir.resolve("outputs/");
        Files.createDirectories(outputsDir);

        // Map the test input jar
        JarRemapper.mapJar(perVersionMappingsJar, OBF_JAR, perVersionMappings, new Path[0], "official", PER_VERSION_NAMESPACE, null);
    }

    @Test
    @Order(1)
    public void testBuildMappingsTiny() throws Exception {
        Path output = outputsDir.resolve("built-mappings.tiny");
        buildMappingsTinyOutput = output;
        BuildMappingsTinyTask.buildMappingsTiny(
            perVersionMappingsJar,
            mappingsDir,
            output
        );

        MappingTree tree = TestUtil.readTinyV2(output);
        assertEquals(PER_VERSION_NAMESPACE, tree.getSrcNamespace());
        assertEquals("named", tree.getDstNamespaces().get(0));
        assertNotNull(tree.getClass("com/example/u/C_001"));
        assertEquals("com/example/AClass", tree.getClass("com/example/u/C_001").getName("named"));
    }

    @Test
    @Order(2)
    public void testInvertPerVersionMappings() throws Exception {
        Path output = outputsDir.resolve("test-intermediate-inverted.tiny");
        invertedPerVersionMappings = output;
        InvertPerVersionMappingsTask.invertMappings(perVersionMappings.toFile(), output.toFile());

        MappingTree inputTree = TestUtil.readTinyV2(perVersionMappings);
        MappingTree outputTree = TestUtil.readTinyV2(output);
        assertEquals(inputTree.getSrcNamespace(), outputTree.getDstNamespaces().get(0));
        assertEquals(inputTree.getDstNamespaces().get(0), outputTree.getSrcNamespace());
        assertEquals(inputTree.getClass("com/example/u/C_001", 0).getName(-1), outputTree.getClass("com/example/u/C_001").getName(0));
    }

    private void testMergedTree(MappingTree tree) {
        assertEquals("official", tree.getSrcNamespace());
        assertIterableEquals(List.of(PER_VERSION_NAMESPACE, "named"), tree.getDstNamespaces());
        assertNotNull(tree.getClass("com/example/u/C_001", 0));
        assertFalse(tree.getClass("com/example/u/C_001", 0).getName("named").isEmpty());
        assertNotNull(tree.getClass("c"));
        assertFalse(tree.getClass("c").getName(PER_VERSION_NAMESPACE).isEmpty()); // Should always have a per-version name
        assertEquals("com/example/u/C_003", tree.getClass("c").getName("named"));
        assertNotNull(tree.getClass("c$a"));
        assertFalse(tree.getClass("c$a").getName(PER_VERSION_NAMESPACE).isEmpty());
    }

    @Test
    @Order(3)
    public void testMergeTiny() throws Exception {
        Path output = outputsDir.resolve("merged.tiny");
        mergeTinyOutput = output;
        MergeTinyTask.mergeMappings(buildMappingsTinyOutput, invertedPerVersionMappings, output);

        MappingTree tree = TestUtil.readTinyV2(output);
        testMergedTree(tree);
    }

    @Test
    @Order(4)
    public void testInsertAutoGeneratedMappings() throws Exception {
        Path output = outputsDir.resolve("insertAutoGeneratedMappings.tiny");
        insertAutoGeneratedMappingsOutput = output;
        AddProposedMappingsTask.addProposedMappings(buildMappingsTinyOutput, output, perVersionMappingsJar, null);

        MappingTree tree = TestUtil.readTinyV2(output);
        MappingTree inputTree = TestUtil.readTinyV2(buildMappingsTinyOutput);
        assertEquals(inputTree.getSrcNamespace(), tree.getSrcNamespace());
        assertEquals(inputTree.getDstNamespaces(), tree.getDstNamespaces());

        assertEquals("com/example/AClass", tree.getClass("com/example/u/C_001").getName("named"));
        assertEquals("com/example/BEnum", tree.getClass("com/example/u/C_002").getName("named"));

        // f_004 FIRST
        MappingTree.FieldMapping insertedField = tree.getField("com/example/u/C_002", "f_004", "Lcom/example/u/C_002;");
        assertNotNull(insertedField);
        assertEquals("FIRST", insertedField.getName("named"));
        MappingTree.FieldMapping prevMapping = inputTree.getField("com/example/u/C_002", "f_004", "Lcom/example/u/C_002;");
        assertNull(prevMapping);

        // f_011 NORMAL
        MappingTree.FieldMapping insertedField2 = tree.getField("com/example/u/C_003$C_004", "f_011", "Lcom/example/u/C_003$C_004;");
        assertNotNull(insertedField2);
        assertEquals("NORMAL", insertedField2.getName("named"));
    }

    @Test
    @Order(4)
    public void testMergeTinyV2() throws Exception {
        Path output = outputsDir.resolve("merged-v2.tiny");
        MergeTinyV2Task.mergeMappings(insertAutoGeneratedMappingsOutput, invertedPerVersionMappings, output);

        MappingTree tree = TestUtil.readTinyV2(output);
        testMergedTree(tree);
        // com/example/u/C_003$C_004 f_011
        assertEquals("NORMAL", tree.getField("c$a", "a", "Lc$a;").getName("named"));
    }

    // TODO: testCombineUnpickDefinitions

    // TODO: testBuildTinyWithEnum

    // TODO: testRemapUnpickDefinitions
}
