import quilt.internal.Constants
import quilt.internal.tasks.build.GenFakeSourceTask

buildscript {
	repositories {
		maven {
			name 'Quilt Releases'
			url 'https://maven.quiltmc.org/repository/release/'
		}
		maven {
			name 'Quilt Snapshot Repository'
			url 'https://maven.quiltmc.org/repository/snapshot/'
		}
		maven {
			name "Fabric Repository"
			url 'https://maven.fabricmc.net'
		}
		// TODO remove when ASM fix is released
		maven {
			url = "https://repository.ow2.org/nexus/content/repositories/snapshots/"
		}
		mavenCentral()
		mavenLocal()
	}
	dependencies {
		classpath(libs.unpick)
		classpath(libs.unpick.format.utils)
	}
}

plugins {
	id 'java' // for constants, packages, javadoc
	id 'maven-publish'
	id 'org.cadixdev.licenser' version '0.6.1'
	id "quilt-mappings"
}

quiltMappings {
	mappingsDir = file('mappings/')

	enigmaProfileConfig = file('enigma/enigma_profile.json')

	unpickMeta = file('unpick/unpick.json')
}

combineUnpickDefinitions {
	// add static unpick definitions
	unpickDefinitions.from 'unpick/definitions/'
}

def USE_SNAPSHOT_HASHES = false

def minecraft_version = Constants.MINECRAFT_VERSION

def ENV = System.getenv()

version = Constants.MAPPINGS_VERSION

if (ENV.BRANCH_NAME) {
	def branch = ENV.BRANCH_NAME.substring(ENV.BRANCH_NAME.lastIndexOf('/') + 1)
	if (minecraft_version != branch) {
		throw new IllegalStateException("Branch name (${branch}) does not match the mc version (${minecraft_version})")
	}
}

repositories {
	maven {
		name "Mojang"
		url 'https://libraries.minecraft.net/'
	}
	mavenCentral()
	maven {
		name "Quilt Repository"
		url "https://maven.quiltmc.org/repository/release"
	}
	maven {
		name "Fabric Repository"
		url 'https://maven.fabricmc.net'
	}
	maven {
		name "Quilt Snapshot Repository"
		url "https://maven.quiltmc.org/repository/snapshot"
	}
	// TODO remove when ASM fix is released
	maven {
		url = "https://repository.ow2.org/nexus/content/repositories/snapshots/"
	}
	mavenLocal()
}

// TODO move at least some of these to MappingsPlugin
configurations {
	javadocClasspath
	unpick
}

dependencies {
	enigmaRuntime(libs.enigma.swing)
	enigmaRuntime(libs.enigma.plugin)
	javadocClasspath(libs.quilt.loader)
	javadocClasspath(libs.jetbrains.annotations)
	javadocClasspath(libs.jsr305) // for some other jsr annotations
	unpick(libs.unpick.cli)
	hashed "org.quiltmc:hashed:${minecraft_version}${USE_SNAPSHOT_HASHES ? "-SNAPSHOT" : ""}"
	intermediary "net.fabricmc:intermediary:${minecraft_version}:v2"
}

// TODO consider moving cleanable things to build/ so this isn't necessary,
//  or put them in .gradle/cleanable/ and only add that here (or MappingsPlugin)
clean.doFirst {
	delete quiltMappings.fileConstants.tempDir
}

tasks.build.dependsOn "compressTiny", "tinyJar", "v2UnmergedMappingsJar", "v2MergedMappingsJar"

// TODO move all custom tasks and their configuration to MappingsPlugin

java {
	sourceCompatibility = JavaVersion.VERSION_21
	targetCompatibility = JavaVersion.VERSION_21
}

tasks.withType(JavaCompile).configureEach {
	it.options.encoding = "UTF-8"
	it.options.release = 21
}

// TODO move at least some of these to MappingsPlugin
sourceSets {
	constants
	packageDocs // package info files
	doclet
}

license {
	header file("HEADER")
	include '**/*.java'
}

// TODO look into alternatives, move to QuiltMappingsPlugin if kept
// Its artifact collides with the `tinyJar` one, just disable it since it isn't used either way
tasks.jar.enabled = false

task sourcesJar(type: Jar, dependsOn: classes) {
	archiveClassifier = "sources"
	from sourceSets.constants.allSource
}

// Only build jars for package infos if we need to actually expose stuff like annotation in the future.

build.dependsOn constantsJar, generatePackageInfoMappings

javadoc {
	dependsOn genFakeSource
	dependsOn downloadMinecraftLibraries
	dependsOn docletClasses // Needed for javadoc to find the doclet classes.
	group = "javadoc generation"
	outputs.upToDateWhen { false }
	destinationDir = file("${buildDir}/docs/${project.version}")
	def docletResources = sourceSets.doclet.resources.asFileTree

	failOnError = true // Failing on error is important to ensure that a Javadoc jar is available.
	maxMemory = '2G'

	// verbose = true // enable to debug
	options {
		// verbose() // enable to debug
		source = "21"
		encoding = 'UTF-8'
		charSet = 'UTF-8'
		memberLevel = JavadocMemberLevel.PRIVATE
		splitIndex true
		tags(
				'apiNote:a:API Note:',
				'implSpec:a:Implementation Requirements:',
				'implNote:a:Implementation Note:'
		)
		taglets "quilt.internal.taglet.MappingTaglet"
		// taglet path, header, extra stylesheet settings deferred
		it.use()

		addBooleanOption "-allow-script-in-comments", true
		links(
				"https://javadoc.io/doc/com.google.guava/guava/${libs.versions.guava.get()}/",
				"https://javadoc.io/doc/com.google.code.gson/gson/${project.gson}/",
				"https://javadoc.io/doc/org.jetbrains/annotations/${libs.versions.jetbrains.annotations.get()}/",
				"https://javadoc.io/doc/com.google.code.findbugs/jsr305/${libs.versions.jsr305.get()}/",
				"https://javadoc.io/doc/org.apache.commons/commons-compress/${project.commons_compress}/",
				"https://javadoc.io/doc/io.netty/netty-all/${project.netty}/",
				'https://javadoc.lwjgl.org/',
				'https://logging.apache.org/log4j/2.x/javadoc/log4j-api/',
				'https://fastutil.di.unimi.it/docs/',
				"https://commons.apache.org/proper/commons-logging/javadocs/api-release/",
				"https://commons.apache.org/proper/commons-lang/javadocs/api-release/",
				"https://commons.apache.org/proper/commons-io/apidocs/",
				"https://commons.apache.org/proper/commons-codec/archives/${project.commons_codec}/apidocs/",
				"https://javadoc.quiltmc.org/quilt-loader/${libs.versions.quilt.loader.get()}/",
				"https://docs.oracle.com/en/java/javase/${project.java}/docs/api/"
		)
		// https://docs.oracle.com/en/java/javase/21/docs/specs/man/javadoc.html#additional-options-provided-by-the-standard-doclet
		addBooleanOption 'Xdoclint:html', true
		addBooleanOption 'Xdoclint:syntax', true
		addBooleanOption 'Xdoclint:reference', true
		addBooleanOption 'Xdoclint:accessibility', true
		addStringOption '-notimestamp'
	}
	source fileTree(tasks.named(GenFakeSourceTask.TASK_NAME, GenFakeSourceTask).flatMap(GenFakeSourceTask::getOutput)) +
		sourceSets.constants.allJava + sourceSets.packageDocs.allJava
	classpath = configurations.javadocClasspath + downloadMinecraftLibraries.outputs.files.asFileTree + mapNamedJar.outputs.files.asFileTree

	doLast {
		project.copy {
			from docletResources
			include "copy_on_click.js"
			into javadoc.outputDirectory
		}
	}

	doFirst {
		// lazy setting
		options {
			tagletPath sourceSets.doclet.output.classesDirs.files.toList()
			header docletResources.filter { it.name == 'javadoc_header.txt' }.singleFile.text.trim()
			addFileOption "-add-stylesheet", docletResources.filter { it.name == 'style.css' }.singleFile
		}
	}
}

task javadocJar(type: Jar, dependsOn: ["javadoc"]) {
	group = "javadoc generation"

	from javadoc.destinationDir

	archiveVersion.set Constants.MAPPINGS_VERSION
	archiveClassifier = 'javadoc'
}

downloadDictionaryFile {
	final revision = libs.versions.dictionary.revision.get()
	// TODO this should probably be published to quilt maven, see #442
	url = "https://raw.githubusercontent.com/ix0rai/qm-base-allowed-wordlist/${revision}/allowed_english_words.txt"

	// TODO does this really need the revision in the name? If not this could go in QuiltMappingsPlugin
	//  Also this seems like something that should go in build/ so it can be cleaned
	output = project.file(".gradle/lint/dictionary/${revision}.txt")
}

// mappingLint {
// 	dependsOn mapPerVersionMappingsJar
// 	mappingDirectory = file("mappings")
// 	jarFile = quiltMappings.fileConstants.perVersionMappingsJar
// }

check.dependsOn mappingLint

publishing {
	publications {
		maven(MavenPublication) {
			groupId 'org.quiltmc'
			artifactId Constants.MAPPINGS_NAME
			version Constants.MAPPINGS_VERSION

			// quilt-mappings-<version>-tiny.gz
			artifact(compressTiny.compressedTiny) {
				classifier "tiny"
				builtBy compressTiny
			}
			// quilt-mappings-<version>.jar
			artifact(tinyJar)
			// quilt-mappings-<version>-v2.jar
			artifact(v2UnmergedMappingsJar) {
				classifier "v2"
			}
			// quilt-mappings-<version>-mergedv2.jar
			artifact(v2MergedMappingsJar) {
				classifier "mergedv2"
			}
			// quilt-mappings-<version>-constants.jar
			artifact(constantsJar) {
				classifier "constants"
			}
			// quilt-mappings-<version>-sources.jar
			artifact sourcesJar
			// quilt-mappings-<version>-javadoc.jar
			artifact javadocJar

			// See below the publishing block for intermediary artifact publishing
		}
	}
	repositories {
		if (ENV.MAVEN_URL) {
			maven {
				url ENV.MAVEN_URL
				credentials {
					username ENV.MAVEN_USERNAME
					password ENV.MAVEN_PASSWORD
				}
			}
		} else if (USE_SNAPSHOT_HASHES && ENV.SNAPSHOTS_URL) {
			maven {
				url = ENV.SNAPSHOTS_URL

				credentials {
					username = ENV.SNAPSHOTS_USERNAME
					password = ENV.SNAPSHOTS_PASSWORD
				}
			}
		}
		mavenLocal()
	}
}

tasks.withType(AbstractPublishToMaven).all { AbstractPublishToMaven t ->
	// Won't run if checkIntermediaryMappings returns false
	dependsOn buildIntermediary

	doFirst {
		if (checkIntermediaryMappings.isPresent()) {
			MavenPublication p = it.publication
			def addArtifact = { Task task, String artifactClassifier ->
				if (p.getArtifacts().findAll {a -> a.getClassifier() == artifactClassifier }.isEmpty()) {
					p.artifact(task) {
						classifier artifactClassifier
					}
				}
			}

			// quilt-mappings-<version>-intermediary-v2.jar
			addArtifact(intermediaryV2MappingsJar, "intermediary-v2")
			// quilt-mappings-<version>-intermediary-mergedv2.jar
			addArtifact(intermediaryV2MergedMappingsJar, "intermediary-mergedv2")
		}
	}
}
