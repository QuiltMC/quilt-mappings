buildscript {
	repositories {
		mavenCentral()
		maven {
			name "Quilt Repositiory"
			url "https://maven.quiltmc.org/repository/release"
		}
		maven {
			name "Fabric Repository"
			url 'https://maven.fabricmc.net'
		}
		mavenCentral()
	}
	dependencies {
		classpath "cuchaz:enigma-cli:${project.enigma_version}"
		classpath "net.fabricmc:stitch:${project.stitch_version}"
		classpath "commons-io:commons-io:2.8.0"
		classpath 'de.undercouch:gradle-download-task:4.1.1'
		classpath 'net.fabricmc:tiny-remapper:0.6.0'
		classpath "net.fabricmc.unpick:unpick:${project.unpick_version}"
		classpath "net.fabricmc.unpick:unpick-format-utils:${project.unpick_version}"
	}
}

plugins {
	id 'java' // for constants, packages, javadoc
	id 'de.undercouch.download'
	id 'maven-publish'
	id 'org.cadixdev.licenser' version '0.6.1'
	id 'net.fabricmc.filament' version '0.3.0'
	id "org.barfuin.gradle.taskinfo" version "1.3.0"
	id "mappings-logic"
}

def USE_SNAPSHOT_HASHES = true

def minecraft_version = "21w38a"

def ENV = System.getenv()
// Fetch build number from Github Actions
def build_number = ENV.BUILD_NUMBER ?: "local"

def mappingsVersion = "${minecraft_version}+build.$build_number"
version = mappingsVersion

if (ENV.BRANCH_NAME) {
	def branch = ENV.BRANCH_NAME.substring(ENV.BRANCH_NAME.lastIndexOf('/') + 1)
	if (minecraft_version != branch) {
		throw new IllegalStateException("Branch name (${branch}) does not match the mc version (${minecraft_version})")
	}
}

repositories {
	mavenCentral()
	maven {
		name "Quilt Repositiory"
		url "https://maven.quiltmc.org/repository/release"
	}
	maven {
		name "Fabric Repository"
		url 'https://maven.fabricmc.net'
	}
	maven {
		name "Mojang"
		url 'https://libraries.minecraft.net/'
	}
	mavenLocal()
	if (USE_SNAPSHOT_HASHES) {
		maven {
			name "Quilt Snapshot Repositiory"
			url "https://maven.quiltmc.org/repository/snapshot"
		}
	}
}

configurations {
	enigmaRuntime {
		resolutionStrategy {
			cacheDynamicVersionsFor 0, "seconds"
			cacheChangingModulesFor 0, "seconds"
		}
	}
	javadocClasspath
	decompileClasspath
	mappingPoetJar {
		transitive = false
	}
	mappingPoet {
		extendsFrom mappingPoetJar
		transitive = true
	}
	unpick
	hashed
}

def unpickMetaFile = file("unpick-definitions/unpick.json")

dependencies {
	enigmaRuntime "cuchaz:enigma-swing:${project.enigma_version}"
	enigmaRuntime "net.fabricmc:stitch:${project.stitch_version}"
	javadocClasspath "net.fabricmc:fabric-loader:${project.fabric_loader_version}"
	javadocClasspath "org.jetbrains:annotations:${project.jetbrains_annotations_version}"
	javadocClasspath "com.google.code.findbugs:jsr305:3.0.2" // for some other jsr annotations
	decompileClasspath "net.fabricmc:cfr:${project.cfr_version}"
	mappingPoetJar "org.quiltmc:mapping-poet:${project.mapping_poet_version}"
	unpick "net.fabricmc.unpick:unpick-cli:${project.unpick_version}"
	hashed "org.quiltmc:hashed-mojmap:${minecraft_version}${USE_SNAPSHOT_HASHES ? "-SNAPSHOT" : ""}"
}

def mappingsGroup = "quilt-mappings"
def buildMappingGroup = "mapping build"
def mapJarGroup = "jar mapping"
def mappingsDir = file("mappings")
def cacheFilesMinecraft = file(".gradle/minecraft")
def tempDir = file(".gradle/temp")
def mergedFile = file("${minecraft_version}-merged.jar")
def hashedMojmapJar = file("${minecraft_version}-hashed.jar")
def unpickedJar = file("${minecraft_version}-hashed-unpicked.jar")
def namedJar = file("${minecraft_version}-named.jar")
def libraries = new File(cacheFilesMinecraft, "libraries")


import cuchaz.enigma.command.ComposeMappingsCommand
import net.fabricmc.stitch.commands.tinyv2.CommandMergeTinyV2
import net.fabricmc.stitch.commands.tinyv2.CommandProposeV2FieldNames
import net.fabricmc.stitch.commands.tinyv2.CommandReorderTinyV2
import quilt.internal.util.JarRemapper

task mappingsUnpicked(dependsOn: "unpickHashedJar") {
	group = mappingsGroup
	doLast {
		ant.setLifecycleLogLevel "WARN"
		ant.java(
				classname: 'cuchaz.enigma.gui.Main',
				classpath: configurations.enigmaRuntime.asPath,
				fork: true,
				spawn: true
		) {
			jvmarg(value: "-Xmx2048m")
			arg(value: '-jar')
			arg(value: unpickedJar.getAbsolutePath())
			arg(value: '-mappings')
			arg(value: mappingsDir.getAbsolutePath())
			arg(value: '-profile')
			arg(value: 'enigma_profile.json')
		}
	}
}

task mappings(dependsOn: mapHashedMojmapJar) {
	group = mappingsGroup
	doLast {
		ant.setLifecycleLogLevel "WARN"
		ant.java(
				classname: 'cuchaz.enigma.gui.Main',
				classpath: configurations.enigmaRuntime.asPath,
				fork: true,
				spawn: true
		) {
			jvmarg(value: "-Xmx2048m")
			arg(value: '-jar')
			arg(value: hashedMojmapJar.getAbsolutePath())
			arg(value: '-mappings')
			arg(value: mappingsDir.getAbsolutePath())
			arg(value: '-profile')
			arg(value: 'enigma_profile.json')
		}
	}
}

clean.doFirst {
	delete tempDir, cacheFilesMinecraft
}

tasks.build.dependsOn "compressTiny", "tinyJar", "v2UnmergedMappingsJar", "v2MergedMappingsJar"

task exportMappingsOfficial(dependsOn: downloadHashedMojmap) {
	def composeInput = downloadHashedMojmap.jarFile

	doLast {
		logger.lifecycle(":exporting mappings")
		String[] args = [
				"tiny",
				composeInput.getAbsolutePath(),
				"enigma",
				file("mappings/").getAbsolutePath(),
				"enigma",
				file("mappings_official/").getAbsolutePath(),
				"right"
		]

		new ComposeMappingsCommand().run(args)
	}
}

task importMappingsOfficial(dependsOn: invertHashedMojmap) {
	def composeInput = invertHashedMojmap.invertedTinyFile

	doLast {
		logger.lifecycle(":importing mappings")
		String[] args = [
				"tiny",
				composeInput.getAbsolutePath(),
				"enigma",
				file("mappings_official/").getAbsolutePath(),
				"enigma",
				file("mappings/").getAbsolutePath(),
				"right"
		]

		new ComposeMappingsCommand().run(args)
	}
}

task buildTinyWithEnum(dependsOn: "mergeTiny", type: FileOutput) {
	group = buildMappingGroup
	def noEnum = mergeTiny.mergedTiny
	output = new File(tempDir, "named-with-enum.tiny")

	outputs.file(output)
	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":seeking auto-mappable fields")
		String[] argsPropose = [
				mergedFile.getAbsolutePath(), // must use official jar
				noEnum.getAbsolutePath(),
				output.getAbsolutePath(),
				"false"
		]

		new CommandProposeV2FieldNames().run(argsPropose)
	}
}

task mapNamedJar(dependsOn: ["mergeV2", "unpickHashedJar"]) {
	group = mapJarGroup
	inputs.files downloadMinecraftLibraries.outputs.files.files
	outputs.file(namedJar)

	//Force the task to always run
	outputs.upToDateWhen { false }

	def jsrToJetbrains = [
			"javax/annotation/Nullable"            : "org/jetbrains/annotations/Nullable",
			"javax/annotation/Nonnull"             : "org/jetbrains/annotations/NotNull",
			"javax/annotation/concurrent/Immutable": "org/jetbrains/annotations/Unmodifiable"
	]

	doLast {
		logger.lifecycle(":mapping minecraft to named")

		JarRemapper.mapJar(namedJar, unpickedJar, (File) mergeV2.output, libraries, "hashed", "named") {
			it.withMappings { out ->
				jsrToJetbrains.each { e ->
					out.acceptClass e.key, e.value
				}
			}
		}
	}
}

combineUnpickDefinitions {
	group = 'unpick'
	input = file('unpick-definitions')
	output = new File(tempDir, 'definitions.unpick')
}

// TODO: Change this in Filament
remapUnpickDefinitionsIntermediary {
	dependsOn buildTinyWithEnum
	group = 'unpick'
	output = new File(tempDir, 'hashed-definitions.unpick')
	targetNamespace = "hashed"
	mappings = buildTinyWithEnum.output
}

task unpickHashedJar(type: JavaExec, dependsOn: [mapHashedMojmapJar, "constantsJar", remapUnpickDefinitionsIntermediary]) {
	outputs.upToDateWhen { false }
	group "unpick"

	mainClass = "daomephsta.unpick.cli.Main"
	systemProperty "java.util.logging.config.file", file('unpick-logging.properties')
	classpath configurations.unpick

	doFirst {
		args hashedMojmapJar.absolutePath, unpickedJar.absolutePath, remapUnpickDefinitionsIntermediary.output.get().asFile.absolutePath, constantsJar.archiveFile.get().asFile.absolutePath

		configurations.decompileClasspath.files.each {
			args it.absolutePath
		}
	}
}

// Setup the build for the unpicked constants

sourceCompatibility = JavaVersion.VERSION_16
targetCompatibility = JavaVersion.VERSION_16

tasks.withType(JavaCompile).configureEach {
	it.options.encoding = "UTF-8"
	it.options.release = 16
}

sourceSets {
	constants
	packageDocs // package info files
}

license {
	header file("HEADER")
	include '**/*.java'
}

task constantsJar(type: Jar) {
	from sourceSets.constants.output
	archiveClassifier = "constants"
}

task sourcesJar(type: Jar, dependsOn: classes) {
	archiveClassifier = "sources"
	from sourceSets.constants.allSource
}

// Only build jars for package infos if we need to actually expose stuff like annotation in the future.

build.dependsOn constantsJar

task insertAutoGeneratedEnumMappings(dependsOn: [buildMappingsTiny, downloadHashedMojmap], type: FileOutput) {
	group = buildMappingGroup
	def noEnumV2 = buildMappingsTiny.outputMappings
	output = new File(tempDir, "unmerged-named-v2-with-enum.tiny")

	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":seeking auto-mappable fields for unmerged mappings")

		String[] argsProposeV2 = [
				hashedMojmapJar.getAbsolutePath(), // must use hashed mojmap jar
				noEnumV2.getAbsolutePath(),
				output.getAbsolutePath(),
				"false" // don't replace existing names right now
		]

		new CommandProposeV2FieldNames().run(argsProposeV2)
	}
}

task mergeV2(dependsOn: ["v2UnmergedMappingsJar", "invertHashedMojmap"], type: FileOutput) {
	def merged = new File(tempDir, "merged.tiny");

	output = new File(tempDir, "merged-reordered.tiny")
	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":merging quilt-mappings and hashed mojmap")
		String[] args = [
				invertHashedMojmap.invertedTinyFile.getAbsolutePath(),
				insertAutoGeneratedEnumMappings.output.getAbsolutePath(),
				merged.getAbsolutePath(),
				"hashed",
				"official"
		]

		new CommandMergeTinyV2().run(args)

		//Reorder the mappings to match the output of loom
		args = [
				merged.getAbsolutePath(),
				output.getAbsolutePath(),
				"official",
				"hashed",
				"named"
		]
		new CommandReorderTinyV2().run(args)
	}
}

task v2UnmergedMappingsJar(dependsOn: [insertAutoGeneratedEnumMappings, combineUnpickDefinitions], type: Jar) {
	def mappings = insertAutoGeneratedEnumMappings.output
	group = "mapping build"
	outputs.upToDateWhen { false }
	archiveFileName = "quilt-mappings-${mappingsVersion}-v2.jar"

	from(file(mappings)) {
		rename mappings.name, "hashed/mappings.tiny"
	}
	from(combineUnpickDefinitions.output) {
		rename combineUnpickDefinitions.output.get().asFile.name, "extras/definitions.unpick"
	}
	from(file(unpickMetaFile)) {
		expand version: project.unpick_version
		rename unpickMetaFile.name, "extras/unpick.json"
	}
	destinationDirectory.set(file("build/libs"))
}

task v2MergedMappingsJar(dependsOn: ["mergeV2"], type: Jar) {
	def mappings = mergeV2.output
	group = "mapping build"
	outputs.upToDateWhen { false }
	archiveFileName = "quilt-mappings-${mappingsVersion}-mergedv2.jar"

	from(file(mappings)) {
		rename mappings.name, "mappings/mappings.tiny"
	}
	from(combineUnpickDefinitions.output) {
		rename combineUnpickDefinitions.output.get().asFile.name, "extras/definitions.unpick"
	}
	from(file(unpickMetaFile)) {
		expand version: project.unpick_version
		rename unpickMetaFile.name, "extras/unpick.json"
	}
	destinationDirectory.set(file("build/libs"))
}

def fakeSourceDir = file(".gradle/temp/fakeSource")
task genFakeSource(type: JavaExec, dependsOn: ["mergeV2", "mapNamedJar"]) {
	group = "javadoc generation"
	outputs.upToDateWhen { false }

	mainClass = "org.quiltmc.mappingpoet.Main"
	classpath configurations.mappingPoet
	// use merged v2 so we have all namespaces in jd
	args mergeV2.output.getAbsolutePath(), namedJar.getAbsolutePath(), fakeSourceDir.getAbsolutePath(), libraries.getAbsolutePath()

	doLast {
		logger.lifecycle ":Fake source generated"
	}
}

task decompileCFR(type: JavaExec, dependsOn: [mapNamedJar]) {
	mainClass = "org.benf.cfr.reader.Main"

	args namedJar.getAbsolutePath(), "--outputdir", file("namedSrc").absolutePath

	doFirst {
		file("namedSrc").deleteDir()
		classpath = configurations.decompileClasspath
	}
}

javadoc {
	dependsOn genFakeSource
	dependsOn downloadMinecraftLibraries
	group = "javadoc generation"
	outputs.upToDateWhen { false }

	if (ENV.CI) {
		// Java 17 is provided on CI to build the javadocs with, see https://github.com/FabricMC/yarn/issues/2429
		javadocTool = javaToolchains.javadocToolFor {
			languageVersion = JavaLanguageVersion.of(17)
		}
	}

	def mappingPoetJar = project.provider { zipTree configurations.mappingPoetJar.singleFile }

	failOnError = false
	maxMemory = '2G'

	// verbose = true // enable to debug
	options {
		// verbose() // enable to debug
		source = "16"
		encoding = 'UTF-8'
		charSet = 'UTF-8'
		memberLevel = JavadocMemberLevel.PRIVATE
		splitIndex true
		tags(
				'apiNote:a:API Note:',
				'implSpec:a:Implementation Requirements:',
				'implNote:a:Implementation Note:'
		)
		taglets "org.quiltmc.mappingpoet.jd.MappingTaglet"
		// taglet path, header, extra stylesheet settings deferred
		it.use()

		addBooleanOption "-allow-script-in-comments", true
		links(
				'https://guava.dev/releases/21.0/api/docs/',
				'https://www.javadoc.io/doc/com.google.code.gson/gson/2.8.0/',
				'https://logging.apache.org/log4j/2.x/log4j-api/apidocs/',
				"https://javadoc.io/doc/org.jetbrains/annotations/${project.jetbrains_annotations_version}/",
				'https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/3.0.2/',
				'https://javadoc.lwjgl.org/',
				'https://fastutil.di.unimi.it/docs/',
				'https://netty.io/4.1/api/',
				'https://commons.apache.org/proper/commons-logging/javadocs/api-1.1.3/',
				'https://commons.apache.org/proper/commons-lang/javadocs/api-3.5',
				'https://commons.apache.org/proper/commons-io/javadocs/api-2.5',
				'https://commons.apache.org/proper/commons-codec/archives/1.10/apidocs',
				'https://commons.apache.org/proper/commons-compress/javadocs/api-1.8.1/',
				"https://maven.fabricmc.net/docs/fabric-loader-${project.fabric_loader_version}/",
				"https://docs.oracle.com/en/java/javase/16/docs/api/"
		)
		// https://docs.oracle.com/en/java/javase/16/docs/specs/man/javadoc.html#additional-options-provided-by-the-standard-doclet
		addBooleanOption 'Xdoclint:html', true
		addBooleanOption 'Xdoclint:syntax', true
		addBooleanOption 'Xdoclint:reference', true
		addBooleanOption 'Xdoclint:accessibility', true
	}
	source fileTree(fakeSourceDir) + sourceSets.constants.allJava + sourceSets.packageDocs.allJava
	classpath = configurations.javadocClasspath.plus downloadMinecraftLibraries.outputs.files.asFileTree

	doLast {
		project.copy {
			from mappingPoetJar
			include "copy_on_click.js"
			into javadoc.outputDirectory
		}
	}

	doFirst {
		// lazy setting
		options {
			tagletPath configurations.mappingPoet.files.toList()
			header mappingPoetJar.get().filter { it.name == 'javadoc_header.txt' }.singleFile.text.trim()
			// cannot include line breaks
			addFileOption "-add-stylesheet", mappingPoetJar.get().filter { it.name == 'forms.css' }.singleFile
		}
	}
}

task javadocJar(type: Jar, dependsOn: ["javadoc"]) {
	group = "javadoc generation"

	from javadoc.destinationDir

	archiveVersion.set mappingsVersion
	archiveClassifier = 'javadoc'
}

generatePackageInfoMappings {
	dependsOn downloadHashedMojmap
	inputJar = hashedMojmapJar
	packageName = "net/minecraft/unused/packageinfo/"
	outputDir = file("mappings/net/minecraft/unused/packageinfo")
}

javadocLint {
	group = "javadoc generation"
	mappingDirectory = file("mappings")
}

check.dependsOn javadocLint

publishing {
	publications {
		maven(MavenPublication) {
			groupId 'org.quiltmc'
			artifactId "quilt-mappings"
			version mappingsVersion

			artifact(compressTiny.compressedTiny) {
				classifier "tiny"
				builtBy compressTiny
			}
			artifact(tinyJar)
			artifact(v2UnmergedMappingsJar) {
				classifier "v2"
			}
			artifact(v2MergedMappingsJar) {
				classifier "mergedv2"
			}
			artifact(constantsJar) {
				classifier "constants"
			}
			artifact sourcesJar
			artifact javadocJar

			pom.withXml {
				def hashedDep = it.asNode().appendNode('dependencies').appendNode('dependency')
				hashedDep.appendNode('groupId', 'org.quiltmc')
				hashedDep.appendNode('artifactId', 'hashed')
				hashedDep.appendNode('version', configurations.hashed.getDependencies().iterator().next().getVersion())
			}
		}
	}
	repositories {
		if (ENV.MAVEN_URL && !USE_SNAPSHOT_HASHES) {
			maven {
				url ENV.MAVEN_URL
				credentials {
					username ENV.MAVEN_USERNAME
					password ENV.MAVEN_PASSWORD
				}
			}
		} else if (USE_SNAPSHOT_HASHES || ENV.SNAPSHOTS_URL) {
			maven {
				url = ENV.SNAPSHOTS_URL

				credentials {
					username = ENV.SNAPSHOTS_USERNAME
					password = ENV.SNAPSHOTS_PASSWORD
				}
			}
		}
		mavenLocal()
	}
}

// A task to ensure that the version being released has not already been released.
task checkVersion {
	doFirst {
		if (USE_SNAPSHOT_HASHES) {
			return
		}

		try {
			def xml = new URL("https://maven.quiltmc.org/repository/release/org/quiltmc/quilt-mappings/maven-metadata.xml").text
			def metadata = new XmlSlurper().parseText(xml)
			def versions = metadata.versioning.versions.version*.text();
			if (versions.contains(version)) {
				throw new RuntimeException("${version} has already been released!")
			}
		} catch (FileNotFoundException e) {
		}
	}
}

publish.mustRunAfter checkVersion

class FileOutput extends DefaultTask {
	@OutputFile
	File output
}
