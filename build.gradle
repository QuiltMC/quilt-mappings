import quilt.internal.tasks.build.MappingsV2JarTask

buildscript {
	repositories {
		maven {
			name 'Quilt Releases'
			url 'https://maven.quiltmc.org/repository/release/'
		}
		maven {
			name 'Quilt Snapshot Repository'
			url 'https://maven.quiltmc.org/repository/snapshot/'
		}
		maven {
			name "Fabric Repository"
			url 'https://maven.fabricmc.net'
		}
		// TODO remove when ASM fix is released
		maven {
			url = "https://repository.ow2.org/nexus/content/repositories/snapshots/"
		}
		mavenCentral()
		mavenLocal()
	}
	dependencies {
		classpath(libs.unpick)
		classpath(libs.unpick.format.utils)
	}
}

plugins {
	id 'java' // for constants, packages, javadoc
	id 'maven-publish'
	id 'org.cadixdev.licenser' version '0.6.1'
	id "quilt-mappings"
}

quiltMappings {
	mappingsDir = file('mappings/')

	enigmaProfileConfig = file('enigma/enigma_profile.json')

	unpickMeta = file('unpick/unpick.json')
}

combineUnpickDefinitions {
	// add static unpick definitions
	unpickDefinitions.from 'unpick/definitions/'
}

def USE_SNAPSHOT_HASHES = false

def minecraft_version = Constants.MINECRAFT_VERSION

def ENV = System.getenv()

version = Constants.MAPPINGS_VERSION

if (ENV.BRANCH_NAME) {
	def branch = ENV.BRANCH_NAME.substring(ENV.BRANCH_NAME.lastIndexOf('/') + 1)
	if (minecraft_version != branch) {
		throw new IllegalStateException("Branch name (${branch}) does not match the mc version (${minecraft_version})")
	}
}

repositories {
	maven {
		name "Mojang"
		url 'https://libraries.minecraft.net/'
	}
	mavenCentral()
	maven {
		name "Quilt Repository"
		url "https://maven.quiltmc.org/repository/release"
	}
	maven {
		name "Fabric Repository"
		url 'https://maven.fabricmc.net'
	}
	maven {
		name "Quilt Snapshot Repository"
		url "https://maven.quiltmc.org/repository/snapshot"
	}
	// TODO remove when ASM fix is released
	maven {
		url = "https://repository.ow2.org/nexus/content/repositories/snapshots/"
	}
	mavenLocal()
}

// TODO move at least some of these to MappingsPlugin
configurations {
	// enigmaRuntime
	javadocClasspath
	// decompileClasspath
	unpick
	// hashed
	// intermediary
}

dependencies {
	enigmaRuntime(libs.enigma.swing)
	enigmaRuntime(libs.enigma.plugin)
	javadocClasspath(libs.quilt.loader)
	javadocClasspath(libs.jetbrains.annotations)
	javadocClasspath(libs.jsr305) // for some other jsr annotations
	unpick(libs.unpick.cli)
	hashed "org.quiltmc:hashed:${minecraft_version}${USE_SNAPSHOT_HASHES ? "-SNAPSHOT" : ""}"
	intermediary "net.fabricmc:intermediary:${minecraft_version}:v2"
}

import org.objectweb.asm.ClassVisitor
import org.objectweb.asm.Opcodes
import org.quiltmc.draftsman.asm.visitor.DraftsmanAdapterClassVisitor
import quilt.internal.Constants
import quilt.internal.decompile.Decompilers
import quilt.internal.tasks.build.TransformJarClassesTask
import quilt.internal.tasks.decompile.DecompileTask
import quilt.internal.tasks.mappings.EnigmaMappingsServerTask
import quilt.internal.tasks.mappings.EnigmaMappingsTask
import quilt.internal.util.MappingsJavadocProvider

// TODO consider moving cleanable things to build/ so this isn't necessary,
//  or put them in .gradle/cleanable/ and only add that here (or MappingsPlugin)
clean.doFirst {
	delete quiltMappings.fileConstants.tempDir, quiltMappings.fileConstants.cacheFilesMinecraft
	// , quiltMappings.fileConstants.generatedUnpickDefinitions
}

tasks.build.dependsOn "compressTiny", "tinyJar", "v2UnmergedMappingsJar", "v2MergedMappingsJar"

// TODO move all custom tasks and their configuration to MappingsPlugin

java {
	sourceCompatibility = JavaVersion.VERSION_21
	targetCompatibility = JavaVersion.VERSION_21
}

tasks.withType(JavaCompile).configureEach {
	it.options.encoding = "UTF-8"
	it.options.release = 21
}

// TODO move at least some of these to MappingsPlugin
sourceSets {
	constants
	packageDocs // package info files
	doclet
}

license {
	header file("HEADER")
	include '**/*.java'
}

// Its artifact collides with the `tinyJar` one, just disable it since it isn't used either way
tasks.jar.enabled = false

task sourcesJar(type: Jar, dependsOn: classes) {
	archiveClassifier = "sources"
	from sourceSets.constants.allSource
}

// Only build jars for package infos if we need to actually expose stuff like annotation in the future.

build.dependsOn constantsJar, generatePackageInfoMappings

task eraseBytecode(type: TransformJarClassesTask, dependsOn: mapNamedJar) {
	jarFile = quiltMappings.fileConstants.namedJar
	output = file(".gradle/temp/erased-classes/")

	visitor(DraftsmanAdapterClassVisitor::new)
	// Set protected/package-private classes to public so that we don't have any access compile errors.
	// TODO: Fix this by putting the classes in the same package. Javadoc shows the modifier
	visitor { new ClassVisitor(Opcodes.ASM9, it) {
		private int toPublicAccess(int access) {
			if ((access & Opcodes.ACC_PROTECTED) != 0 || ((access & Opcodes.ACC_PRIVATE) == 0 && (access & Opcodes.ACC_PUBLIC) == 0)) {
				access = access & ~Opcodes.ACC_PROTECTED
				access = access | Opcodes.ACC_PUBLIC
			}
			return access
		}

		@Override
		void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
			super.visit(version, toPublicAccess(access), name, signature, superName, interfaces)
		}

		@Override
		void visitInnerClass(String name, String outerName, String innerName, int access) {
			super.visitInnerClass(name, outerName, innerName, toPublicAccess(access))
		}
	} }

	filter({ it.outerClass == null }) // filter out anonymous classes
}

def fakeSourceDir = file(".gradle/temp/fakeSource")
task genFakeSource(type: DecompileTask, dependsOn: [mergeTinyV2, eraseBytecode]) {
	input = eraseBytecode.output.asFile.get()
	output = fakeSourceDir
	decompiler = Decompilers.VINEFLOWER
	libraries = files(quiltMappings.fileConstants.libraries)
	decompilerOptions = [
			"rsy": "1", // remove synthetics
			"dgs": "1", // decompile generic signatures
			"pll": "99999" // pll (Preferred Line Length) is length for line wrapping
	]

	// Tell gradle not to skip if the mappings file changed
	inputs.file(mergeTinyV2.outputMappings)

	doFirst {
		fakeSourceDir.deleteDir()

		def jdProvider = new MappingsJavadocProvider(mergeTinyV2.outputMappings.get().getAsFile(), "named")
		classJavadocProvider(jdProvider)
		fieldJavadocProvider(jdProvider)
		methodJavadocProvider(jdProvider)
	}
	doLast {
		logger.lifecycle ":Fake source generated"
	}
}

task decompileVineflower(type: DecompileTask, dependsOn: [mapNamedJar]) {
	input.set quiltMappings.fileConstants.namedJar
	output.set file("namedSrc")
	decompiler = Decompilers.VINEFLOWER
	libraries = files(configurations.decompileClasspath)

	doFirst {
		file("namedSrc").deleteDir()

		def javadocProvider =
			new MappingsJavadocProvider(insertAutoGeneratedMappings.outputMappings.get().getAsFile(), "named")
		classJavadocProvider(javadocProvider)
		fieldJavadocProvider(javadocProvider)
		methodJavadocProvider(javadocProvider)
	}
}

javadoc {
	dependsOn genFakeSource
	dependsOn downloadMinecraftLibraries
	dependsOn docletClasses // Needed for javadoc to find the doclet classes.
	group = "javadoc generation"
	outputs.upToDateWhen { false }
	destinationDir = file("${buildDir}/docs/${project.version}")
	def docletResources = sourceSets.doclet.resources.asFileTree

	failOnError = true // Failing on error is important to ensure that a Javadoc jar is available.
	maxMemory = '2G'

	// verbose = true // enable to debug
	options {
		// verbose() // enable to debug
		source = "21"
		encoding = 'UTF-8'
		charSet = 'UTF-8'
		memberLevel = JavadocMemberLevel.PRIVATE
		splitIndex true
		tags(
				'apiNote:a:API Note:',
				'implSpec:a:Implementation Requirements:',
				'implNote:a:Implementation Note:'
		)
		taglets "quilt.internal.taglet.MappingTaglet"
		// taglet path, header, extra stylesheet settings deferred
		it.use()

		addBooleanOption "-allow-script-in-comments", true
		links(
				"https://javadoc.io/doc/com.google.guava/guava/${libs.versions.guava.get()}/",
				"https://javadoc.io/doc/com.google.code.gson/gson/${project.gson}/",
				"https://javadoc.io/doc/org.jetbrains/annotations/${libs.versions.jetbrains.annotations.get()}/",
				"https://javadoc.io/doc/com.google.code.findbugs/jsr305/${libs.versions.jsr305.get()}/",
				"https://javadoc.io/doc/org.apache.commons/commons-compress/${project.commons_compress}/",
				"https://javadoc.io/doc/io.netty/netty-all/${project.netty}/",
				'https://javadoc.lwjgl.org/',
				'https://logging.apache.org/log4j/2.x/javadoc/log4j-api/',
				'https://fastutil.di.unimi.it/docs/',
				"https://commons.apache.org/proper/commons-logging/javadocs/api-release/",
				"https://commons.apache.org/proper/commons-lang/javadocs/api-release/",
				"https://commons.apache.org/proper/commons-io/apidocs/",
				"https://commons.apache.org/proper/commons-codec/archives/${project.commons_codec}/apidocs/",
				"https://javadoc.quiltmc.org/quilt-loader/${libs.versions.quilt.loader.get()}/",
				"https://docs.oracle.com/en/java/javase/${project.java}/docs/api/"
		)
		// https://docs.oracle.com/en/java/javase/21/docs/specs/man/javadoc.html#additional-options-provided-by-the-standard-doclet
		addBooleanOption 'Xdoclint:html', true
		addBooleanOption 'Xdoclint:syntax', true
		addBooleanOption 'Xdoclint:reference', true
		addBooleanOption 'Xdoclint:accessibility', true
		addStringOption '-notimestamp'
	}
	source fileTree(fakeSourceDir) + sourceSets.constants.allJava + sourceSets.packageDocs.allJava
	classpath = configurations.javadocClasspath + downloadMinecraftLibraries.outputs.files.asFileTree + mapNamedJar.outputs.files.asFileTree

	doLast {
		project.copy {
			from docletResources
			include "copy_on_click.js"
			into javadoc.outputDirectory
		}
	}

	doFirst {
		// lazy setting
		options {
			tagletPath sourceSets.doclet.output.classesDirs.files.toList()
			header docletResources.filter { it.name == 'javadoc_header.txt' }.singleFile.text.trim()
			addFileOption "-add-stylesheet", docletResources.filter { it.name == 'style.css' }.singleFile
		}
	}
}

task javadocJar(type: Jar, dependsOn: ["javadoc"]) {
	group = "javadoc generation"

	from javadoc.destinationDir

	archiveVersion.set Constants.MAPPINGS_VERSION
	archiveClassifier = 'javadoc'
}

generatePackageInfoMappings {
	packageName = "net/minecraft/unused/packageinfo/"
}

mappingLint {
	dependsOn mapPerVersionMappingsJar
	mappingDirectory = file("mappings")
	jarFile = quiltMappings.fileConstants.perVersionMappingsJar
}

check.dependsOn mappingLint

publishing {
	publications {
		maven(MavenPublication) {
			groupId 'org.quiltmc'
			artifactId Constants.MAPPINGS_NAME
			version Constants.MAPPINGS_VERSION

			// quilt-mappings-<version>-tiny.gz
			artifact(compressTiny.compressedTiny) {
				classifier "tiny"
				builtBy compressTiny
			}
			// quilt-mappings-<version>.jar
			artifact(tinyJar)
			// quilt-mappings-<version>-v2.jar
			artifact(v2UnmergedMappingsJar) {
				classifier "v2"
			}
			// quilt-mappings-<version>-mergedv2.jar
			artifact(v2MergedMappingsJar) {
				classifier "mergedv2"
			}
			// quilt-mappings-<version>-constants.jar
			artifact(constantsJar) {
				classifier "constants"
			}
			// quilt-mappings-<version>-sources.jar
			artifact sourcesJar
			// quilt-mappings-<version>-javadoc.jar
			artifact javadocJar

			// See below the publishing block for intermediary artifact publishing
		}
	}
	repositories {
		if (ENV.MAVEN_URL) {
			maven {
				url ENV.MAVEN_URL
				credentials {
					username ENV.MAVEN_USERNAME
					password ENV.MAVEN_PASSWORD
				}
			}
		} else if (USE_SNAPSHOT_HASHES && ENV.SNAPSHOTS_URL) {
			maven {
				url = ENV.SNAPSHOTS_URL

				credentials {
					username = ENV.SNAPSHOTS_USERNAME
					password = ENV.SNAPSHOTS_PASSWORD
				}
			}
		}
		mavenLocal()
	}
}

tasks.withType(AbstractPublishToMaven).all { AbstractPublishToMaven t ->
	// Won't run if checkIntermediaryMappings returns false
	dependsOn buildIntermediary

	doFirst {
		if (checkIntermediaryMappings.isPresent()) {
			MavenPublication p = it.publication
			def addArtifact = { Task task, String artifactClassifier ->
				if (p.getArtifacts().findAll {a -> a.getClassifier() == artifactClassifier }.isEmpty()) {
					p.artifact(task) {
						classifier artifactClassifier
					}
				}
			}

			// quilt-mappings-<version>-intermediary-v2.jar
			addArtifact(intermediaryV2MappingsJar, "intermediary-v2")
			// quilt-mappings-<version>-intermediary-mergedv2.jar
			addArtifact(intermediaryV2MergedMappingsJar, "intermediary-mergedv2")
		}
	}
}
