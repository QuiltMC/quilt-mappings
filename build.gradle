buildscript {
	repositories {
		maven {
			name 'Quilt Releases'
			url 'https://maven.quiltmc.org/repository/release/'
		}
		maven {
			name 'Quilt Snapshot Repository'
			url 'https://maven.quiltmc.org/repository/snapshot/'
		}
		maven {
			name "Fabric Repository"
			url 'https://maven.fabricmc.net'
		}
		mavenCentral()
	}
	dependencies {
		classpath(libs.unpick)
		classpath(libs.unpick.format.utils)
	}
}

plugins {
	id 'java' // for constants, packages, javadoc
	id 'maven-publish'
	id 'org.cadixdev.licenser' version '0.6.1'
	id "mappings-logic"
}

def USE_SNAPSHOT_HASHES = false

def minecraft_version = Constants.MINECRAFT_VERSION

def ENV = System.getenv()

version = Constants.MAPPINGS_VERSION

if (ENV.BRANCH_NAME) {
	def branch = ENV.BRANCH_NAME.substring(ENV.BRANCH_NAME.lastIndexOf('/') + 1)
	if (minecraft_version != branch) {
		throw new IllegalStateException("Branch name (${branch}) does not match the mc version (${minecraft_version})")
	}
}

repositories {
	mavenCentral()
	maven {
		name "Quilt Repository"
		url "https://maven.quiltmc.org/repository/release"
	}
	maven {
		name "Fabric Repository"
		url 'https://maven.fabricmc.net'
	}
	maven {
		name "Mojang"
		url 'https://libraries.minecraft.net/'
	}
	maven {
		name "Quilt Snapshot Repository"
		url "https://maven.quiltmc.org/repository/snapshot"
	}
}

configurations {
	enigmaRuntime
	javadocClasspath
	decompileClasspath
	unpick
	hashed
	intermediary
}

dependencies {
	enigmaRuntime(libs.enigma.swing)
	enigmaRuntime(libs.enigma.plugin)
	javadocClasspath(libs.fabric.loader)
	javadocClasspath(libs.jetbrains.annotations)
	javadocClasspath(libs.jsr305) // for some other jsr annotations
	decompileClasspath(libs.cfr)
	unpick(libs.unpick.cli)
	hashed "org.quiltmc:hashed:${minecraft_version}${USE_SNAPSHOT_HASHES ? "-SNAPSHOT" : ""}"
	intermediary "net.fabricmc:intermediary:${minecraft_version}:v2"
}


import org.objectweb.asm.ClassVisitor
import org.objectweb.asm.Opcodes
import org.quiltmc.draftsman.asm.visitor.DraftsmanAdapterClassVisitor
import quilt.internal.Constants
import quilt.internal.decompile.Decompilers
import quilt.internal.tasks.build.AddProposedMappingsTask
import quilt.internal.tasks.build.MappingsV2JarTask
import quilt.internal.tasks.build.TransformJarClassesTask
import quilt.internal.tasks.decompile.DecompileTask
import quilt.internal.tasks.jarmapping.MapPerVersionMappingsJarTask
import quilt.internal.tasks.mappings.EnigmaMappingsTask
import quilt.internal.tasks.unpick.UnpickJarTask
import quilt.internal.util.MappingsJavadocProvider

clean.doFirst {
	delete mappings.fileConstants.tempDir, mappings.fileConstants.cacheFilesMinecraft,
			mappings.fileConstants.unpickGlDefinitions, mappings.fileConstants.unpickGlStateManagerDefinitions
}

tasks.build.dependsOn "compressTiny", "tinyJar", "v2UnmergedMappingsJar", "v2MergedMappingsJar"

task buildTinyWithEnum(dependsOn: "mergeTiny", type: AddProposedMappingsTask) {
	inputJar.set mergeJars.mergedFile
	inputMappings.set mergeTiny.outputMappings
	profile.set file("enigma_profile.json")
}

task insertAutoGeneratedMappings(dependsOn: [buildMappingsTiny, downloadPerVersionMappings], type: AddProposedMappingsTask) {
	inputJar.set mappings.fileConstants.perVersionMappingsJar
	inputMappings.set buildMappingsTiny.outputMappings
	profile.set file("enigma_profile.json")
}

combineUnpickDefinitions {
	input = mappings.fileConstants.unpickDefinitions
	output = new File(mappings.fileConstants.buildDir, 'definitions.unpick')
}

remapUnpickDefinitions {
	dependsOn buildTinyWithEnum
	output = new File(project.extensions.getByName("mappings").fileConstants.buildDir as File, Constants.PER_VERSION_MAPPINGS_NAME + '-definitions.unpick')
	mappings = buildTinyWithEnum.outputMappings
}

sourceCompatibility = JavaVersion.VERSION_17
targetCompatibility = JavaVersion.VERSION_17

tasks.withType(JavaCompile).configureEach {
	it.options.encoding = "UTF-8"
	it.options.release = 17
}

sourceSets {
	constants
	packageDocs // package info files
	doclet
}

license {
	header file("HEADER")
	include '**/*.java'
}

task constantsJar(type: Jar) {
	from sourceSets.constants.output
	archiveClassifier = "constants"
}

task sourcesJar(type: Jar, dependsOn: classes) {
	archiveClassifier = "sources"
	from sourceSets.constants.allSource
}

task unpickHashedJar(type: UnpickJarTask) {
	inputFile.set mappings.fileConstants.perVersionMappingsJar
	outputFile.set mappings.fileConstants.unpickedJar
	unpickDefinition.set remapUnpickDefinitions.output.get()
	unpickConstantsJar.set constantsJar.archiveFile

	dependsOn MapPerVersionMappingsJarTask.TASK_NAME, "constantsJar", remapUnpickDefinitions
}

task mappingsUnpicked(type: EnigmaMappingsTask, dependsOn: unpickHashedJar) {
	jarToMap.set unpickHashedJar.outputFile.get()
}

task mappings(type: EnigmaMappingsTask, dependsOn: "mapPerVersionMappingsJar") {
	jarToMap.set mappings.fileConstants.perVersionMappingsJar
}

// Only build jars for package infos if we need to actually expose stuff like annotation in the future.

build.dependsOn constantsJar, generatePackageInfoMappings

task v2UnmergedMappingsJar(type: MappingsV2JarTask, dependsOn: [insertAutoGeneratedMappings, combineUnpickDefinitions]) {
	archiveFileName = "${Constants.MAPPINGS_NAME}-${Constants.MAPPINGS_VERSION}-v2.jar"
	mappings = insertAutoGeneratedMappings.outputMappings
}

task v2MergedMappingsJar(dependsOn: ["mergeTinyV2"], type: MappingsV2JarTask) {
	archiveFileName = "${Constants.MAPPINGS_NAME}-${Constants.MAPPINGS_VERSION}-mergedv2.jar"
	mappings = mergeTinyV2.outputMappings
}

task intermediaryV2MappingsJar(dependsOn: ["removeIntermediary"], type: MappingsV2JarTask) {
	archiveFileName = "${Constants.MAPPINGS_NAME}-${Constants.MAPPINGS_VERSION}-intermediary-v2.jar"
	mappings = removeIntermediary.outputMappings

	onlyIf {
		return checkIntermediaryMappings.isPresent()
	}
}

task intermediaryV2MergedMappingsJar(dependsOn: ["mergeIntermediary"], type: MappingsV2JarTask) {
	archiveFileName = "${Constants.MAPPINGS_NAME}-${Constants.MAPPINGS_VERSION}-intermediary-mergedv2.jar"
	mappings = mergeIntermediary.outputMappings

	onlyIf {
		return checkIntermediaryMappings.isPresent()
	}
}

task buildIntermediary {
	dependsOn intermediaryV2MappingsJar, intermediaryV2MergedMappingsJar

	onlyIf {
		return checkIntermediaryMappings.isPresent()
	}
}

task eraseBytecode(type: TransformJarClassesTask, dependsOn: mapNamedJar) {
	jarFile = mappings.fileConstants.namedJar
	output = file(".gradle/temp/erased-classes/")
	visitor(DraftsmanAdapterClassVisitor::new)
	// Set protected/package-private classes to public so that we don't have any access compile errors.
	// TODO: Fix this by putting the classes in the same package. Javadoc shows the modifier
	visitor { new ClassVisitor(Opcodes.ASM9, it) {
		private int toPublicAccess(int access) {
			if ((access & Opcodes.ACC_PROTECTED) != 0 || ((access & Opcodes.ACC_PRIVATE) == 0 && (access & Opcodes.ACC_PUBLIC) == 0)) {
				access = access & ~Opcodes.ACC_PROTECTED
				access = access | Opcodes.ACC_PUBLIC
			}
			return access
		}

		@Override
		void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
			super.visit(version, toPublicAccess(access), name, signature, superName, interfaces)
		}

		@Override
		void visitInnerClass(String name, String outerName, String innerName, int access) {
			super.visitInnerClass(name, outerName, innerName, toPublicAccess(access))
		}
	} }

	filter({ it.outerClass == null }) // filter out anonymous classes
}

def fakeSourceDir = file(".gradle/temp/fakeSource")
task genFakeSource(type: DecompileTask, dependsOn: [mergeTinyV2, eraseBytecode]) {
	input = eraseBytecode.output.asFile.get()
	output = fakeSourceDir
	decompiler = Decompilers.QUILTFLOWER
	libraries = files(mappings.fileConstants.libraries)
	decompilerOptions = [
			"rsy": "1", // remove synthetics
			"dgs": "1", // decompile generic signatures
			"pll": "99999" // pll (Preferred Line Length) is length for line wrapping
	]

	// Tell gradle not to skip if the mappings file changed
	inputs.file(mergeTinyV2.outputMappings)

	doFirst {
		fakeSourceDir.deleteDir()

		def jdProvider = new MappingsJavadocProvider(mergeTinyV2.outputMappings, "named")
		classJavadocProvider(jdProvider)
		fieldJavadocProvider(jdProvider)
		methodJavadocProvider(jdProvider)
	}
	doLast {
		logger.lifecycle ":Fake source generated"
	}
}

task decompileCFR(type: DecompileTask, dependsOn: [mapNamedJar]) {
	input.set mappings.fileConstants.namedJar
	output.set file("namedSrc")
	decompiler = Decompilers.CFR
	libraries = configurations.decompileClasspath

	doFirst {
		file("namedSrc").deleteDir()
	}
}

task decompileQuiltflower(type: DecompileTask, dependsOn: [mapNamedJar]) {
	input.set mappings.fileConstants.namedJar
	output.set file("namedSrc")
	decompiler = Decompilers.QUILTFLOWER
	libraries = configurations.decompileClasspath

	doFirst {
		file("namedSrc").deleteDir()

		def javadocProvider = new MappingsJavadocProvider(insertAutoGeneratedMappings.outputMappings, "named")
		classJavadocProvider(javadocProvider)
		fieldJavadocProvider(javadocProvider)
		methodJavadocProvider(javadocProvider)
	}
}

task unpickTargetJar(type: UnpickJarTask) {
	dependsOn "checkUnpickVersionsMatch", "downloadMinecraftLibraries"

	inputFile.set remapTargetMinecraftJar.outputJar
	outputFile.set file(Constants.MINECRAFT_VERSION + "-target-named.jar")
	unpickDefinition.set downloadTargetMappingsJar.targetUnpickDefinitionsFile
	unpickConstantsJar.set downloadTargetMappingsJar.targetUnpickConstantsFile

	onlyIf {
		checkUnpickVersionsMatch.match
	}
}

task decompileTargetQuiltflower(type: DecompileTask, dependsOn: [unpickTargetJar]) {
	input.set unpickTargetJar.outputFile
	output.set file("namedTargetSrc")
	decompiler = Decompilers.QUILTFLOWER
	libraries = configurations.decompileClasspath

	doFirst {
		file("namedTargetSrc").deleteDir()

		def javadocProvider = new MappingsJavadocProvider(downloadTargetMappingsJar.targetMappingsFile.get().getAsFile(), "named")
		classJavadocProvider(javadocProvider)
		fieldJavadocProvider(javadocProvider)
		methodJavadocProvider(javadocProvider)
	}

	onlyIf {
		checkUnpickVersionsMatch.match
	}
}

javadoc {
	dependsOn genFakeSource
	dependsOn downloadMinecraftLibraries
	dependsOn docletClasses // Needed for javadoc to find the doclet classes.
	group = "javadoc generation"
	outputs.upToDateWhen { false }

	def docletResources = sourceSets.doclet.resources.asFileTree

	failOnError = true // Failing on error is important to ensure that a Javadoc jar is available.
	maxMemory = '2G'

	// verbose = true // enable to debug
	options {
		// verbose() // enable to debug
		source = "17"
		encoding = 'UTF-8'
		charSet = 'UTF-8'
		memberLevel = JavadocMemberLevel.PRIVATE
		splitIndex true
		tags(
				'apiNote:a:API Note:',
				'implSpec:a:Implementation Requirements:',
				'implNote:a:Implementation Note:'
		)
		taglets "quilt.internal.taglet.MappingTaglet"
		// taglet path, header, extra stylesheet settings deferred
		it.use()

		addBooleanOption "-allow-script-in-comments", true
		links(
				"https://javadoc.io/doc/com.google.guava/guava/${libs.versions.guava.get()}/",
				"https://javadoc.io/doc/com.google.code.gson/gson/${project.gson}/",
				"https://javadoc.io/doc/org.jetbrains/annotations/${libs.versions.jetbrains.annotations.get()}/",
				"https://javadoc.io/doc/com.google.code.findbugs/jsr305/${libs.versions.jsr305.get()}/",
				"https://javadoc.io/doc/org.apache.commons/commons-compress/${project.commons_compress}/",
				"https://javadoc.io/doc/io.netty/netty-all/${project.netty}/",
				'https://javadoc.lwjgl.org/',
				'https://logging.apache.org/log4j/2.x/log4j-api/apidocs/',
//				'https://fastutil.di.unimi.it/docs/',
				"https://commons.apache.org/proper/commons-logging/javadocs/api-release/",
				"https://commons.apache.org/proper/commons-lang/javadocs/api-release/",
				"https://commons.apache.org/proper/commons-io/apidocs/",
				"https://commons.apache.org/proper/commons-codec/archives/${project.commons_codec}/apidocs/",
				"https://maven.fabricmc.net/docs/fabric-loader-${libs.versions.fabric.loader.get()}/",
				"https://docs.oracle.com/en/java/javase/${project.java}/docs/api/"
		)
		// https://docs.oracle.com/en/java/javase/17/docs/specs/man/javadoc.html#additional-options-provided-by-the-standard-doclet
		addBooleanOption 'Xdoclint:html', true
		addBooleanOption 'Xdoclint:syntax', true
		addBooleanOption 'Xdoclint:reference', true
		addBooleanOption 'Xdoclint:accessibility', true
	}
	source fileTree(fakeSourceDir) + sourceSets.constants.allJava + sourceSets.packageDocs.allJava
	classpath = configurations.javadocClasspath + downloadMinecraftLibraries.outputs.files.asFileTree + mapNamedJar.outputs.files.asFileTree

	doLast {
		project.copy {
			from docletResources
			include "copy_on_click.js"
			into javadoc.outputDirectory
		}
	}

	doFirst {
		// lazy setting
		options {
			tagletPath sourceSets.doclet.output.classesDirs.files.toList()
			header docletResources.filter { it.name == 'javadoc_header.txt' }.singleFile.text.trim()
			addFileOption "-add-stylesheet", docletResources.filter { it.name == 'style.css' }.singleFile
		}
	}
}

task javadocJar(type: Jar, dependsOn: ["javadoc"]) {
	group = "javadoc generation"

	from javadoc.destinationDir

	archiveVersion.set Constants.MAPPINGS_VERSION
	archiveClassifier = 'javadoc'
}

generatePackageInfoMappings {
	packageName = "net/minecraft/unused/packageinfo/"
}

mappingLint {
	dependsOn mapPerVersionMappingsJar
	mappingDirectory = file("mappings")
	jarFile = mappings.fileConstants.perVersionMappingsJar
}

check.dependsOn mappingLint

publishing {
	publications {
		maven(MavenPublication) {
			groupId 'org.quiltmc'
			artifactId Constants.MAPPINGS_NAME
			version Constants.MAPPINGS_VERSION

			artifact(compressTiny.compressedTiny) {
				classifier "tiny"
				builtBy compressTiny
			}
			artifact(tinyJar)
			artifact(v2UnmergedMappingsJar) {
				classifier "v2"
			}
			artifact(v2MergedMappingsJar) {
				classifier "mergedv2"
			}
			artifact(constantsJar) {
				classifier "constants"
			}
			artifact sourcesJar
			artifact javadocJar

			// See below the publishing block for intermediary artifact publishing
		}
	}
	repositories {
		if (ENV.MAVEN_URL) {
			maven {
				url ENV.MAVEN_URL
				credentials {
					username ENV.MAVEN_USERNAME
					password ENV.MAVEN_PASSWORD
				}
			}
		} else if (USE_SNAPSHOT_HASHES && ENV.SNAPSHOTS_URL) {
			maven {
				url = ENV.SNAPSHOTS_URL

				credentials {
					username = ENV.SNAPSHOTS_USERNAME
					password = ENV.SNAPSHOTS_PASSWORD
				}
			}
		}
		mavenLocal()
	}
}

tasks.withType(AbstractPublishToMaven).all { AbstractPublishToMaven t ->
	// Won't run if checkIntermediaryMappings returns false
	dependsOn buildIntermediary

	doFirst {
		if (checkIntermediaryMappings.isPresent()) {
			MavenPublication p = it.publication
			def addArtifact = { Task task, String artifactClassifier ->
				if (p.getArtifacts().findAll {a -> a.getClassifier() == artifactClassifier }.isEmpty()) {
					p.artifact(task) {
						classifier artifactClassifier
					}
				}
			}

			addArtifact(intermediaryV2MappingsJar, "intermediary-v2")
			addArtifact(intermediaryV2MergedMappingsJar, "intermediary-mergedv2")
		}
	}
}
